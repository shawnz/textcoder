<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><script src="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/athena.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app203.us.archive.org';v.server_ms=374;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://bijective.dogma.net/compres12.htm","20210805175333","https://web.archive.org/","web","/_static/",
	      "1628186013");
</script>
<link rel="stylesheet" type="text/css" href="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<title>BEST TWO SYMBOL BIJECTIVE ADAPTIVE ARITHMETIC COMPRESSION</title></head>
<body background="BEST%20TWO%20SYMBOL%20BIJECTIVE%20ADAPTIVE%20ARITHMETIC%20COMPRESSION_files/01_bkg4.jpg"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr; height: 67px;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20210805175333/http://bijective.dogma.net/compres12.htm</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://bijective.dogma.net/compres12.htm","20210805175333",1996,"/_static/",["/_static/css/banner-styles.css?v=S1zqJCYt","/_static/css/iconochive.css?v=3PDvdIFv"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 


<center><h2>David' Scott's  Reverse Arthmetic</h2></center>
<p>


<i>files updated on August 9,2004<br></i>

</p><h3>
<p> This is loosely based on a discussion with David Cary see
his site
<a href="https://web.archive.org/web/20210805175333/http://www.rdrop.com/~cary/html/data_compression.html#reverse_huffman">site</a> </p><p> The problem is this one
has a set of binary string messages but instead of being able to
write ones and zeros say  some other set of symbols is used say A B C
Where one wants to minimize the cost of the message for some
cost to  A B C.  One way to solve the problem is to find the probability
that would give an expansion such that  (weight or cost of symbol ) / (
expansion length of symbol ) is a constant. I choose 3 symbols since
its the first interesting case. Its actually a mod to ARB255 it would
be easy to expand to more than 3 symbols or even do 2 symbols</p><p> 


</p><p></p><p>To use this</p><p>
unarb3w filein fileout weightfile</p><p>
filein file of ascii 1's and 0's only<br>
fileout file of A's B's C's bijective replacement of filein<br>
weightfile  3 line file of relative costs of A B C<br></p><p></p><p>

arb3w filen fileout weightfile</p><p>
reverse of previous<br><br>
 
</p></h3><h4>
<a href="https://web.archive.org/web/20210805175333/http://bijective.dogma.net/arb3w.zip">REVERSE ARITHMETIC USING ARB2X CELL arb3w.zip</a><p>
<a href="https://web.archive.org/web/20210805175333/http://bijective.dogma.net/arb255.zip">NEW STABLE ARB255 BIJECTIVE COMPRESSOR arb255.zip</a>
</p></h4>
<font size="+1"><b><pre>
<table border="1">
<caption align="middle">Table 1: The encoding process</caption>
<tbody><tr><th>Postion </th><th>infinite finitely odd value </th><th>Unque Binary string</th><th>weights 1,2,2</th><th>weights 1,1,1 </th><th>weights 12,38,55 </th></tr>
<tr><th>1.</th><td>[1]100000...</td><td>(1) <font color="#c00000">1</font></td><td>(1)<font color="#c00000">A</font></td><td>(1)<font color="#c00000">A</font></td><td>(12)<font color="#c00000">A</font></td></tr>
<tr><th>2.</th><td>[2]010000...</td><td>(1) <font color="#c00000">0</font></td><td>(2)<font color="#c00000">B</font></td><td>(2)<font color="#c00000">A A</font></td><td>(38)<font color="#c00000">B</font></td></tr>
<tr><th>3.</th><td>[2]110000...</td><td>(2) <font color="#c00000">1 1</font></td><td>(2)<font color="#c00000">A A</font></td><td>(1)<font color="#c00000">B</font></td><td>(24)<font color="#c00000">A A</font></td></tr>
<tr><th>4.</th><td>[3]001000...</td><td>(2) <font color="#c00000">0 0 </font> </td><td>(2)<font color="#c00000">C</font></td><td>(2)<font color="#c00000">A B</font></td><td>(55)<font color="#c00000">C</font></td></tr>
<tr><th>5.</th><td>[3]101000...</td><td>(2) <font color="#c00000">1 0</font> </td><td>(3)<font color="#c00000">A B</font></td><td>(2)<font color="#c00000">B B</font></td><td>(36)<font color="#c00000">A A A</font></td></tr>
<tr><th>6.</th><td>[3]011000...</td><td>(2) <font color="#c00000">0 1</font> </td><td>(3)<font color="#c00000">B A</font></td><td>(2)<font color="#c00000">B A</font></td><td>(50)<font color="#c00000">A B</font></td></tr>
<tr><th>7.</th><td>[3]111000...</td><td>(3) <font color="#c00000">1 1 1</font> </td><td>(3)<font color="#c00000">A A A</font></td><td>(1)<font color="#c00000">C</font></td><td>(48)<font color="#c00000">A A A A</font></td></tr>
<tr><th>8.</th><td>[4]000100...</td><td>(3) <font color="#c00000">0 0 0</font> </td><td>(4)<font color="#c00000">C B</font></td><td>(3)<font color="#c00000">A A A</font></td><td>(67)<font color="#c00000">C A</font></td></tr>
<tr><th>9.</th><td>[4]100100...</td><td>(3) <font color="#c00000">1 0 0</font> </td><td>(3)<font color="#c00000">A C</font></td><td>(2)<font color="#c00000">B C</font></td><td>(62)<font color="#c00000">A B A</font></td></tr>
<tr><th>10.</th><td>[4]01010...</td><td>(3) <font color="#c00000">0 1 0</font> </td><td>(4)<font color="#c00000">B B</font></td><td>(3)<font color="#c00000">A B A</font></td><td>(62)<font color="#c00000">B A A</font></td></tr>
<tr><th>11.</th><td>[4]110100..</td><td>(3) <font color="#c00000">1 1 0</font> </td><td>(4)<font color="#c00000">A A B</font></td><td>(2)<font color="#c00000">C B</font></td><td>(74)<font color="#c00000">A A A B</font></td></tr>
<tr><th>12.</th><td>[4]001100..</td><td>(3) <font color="#c00000">0 0 1</font> </td><td>(3)<font color="#c00000">C A</font></td><td>(2)<font color="#c00000">A C</font></td><td>(50)<font color="#c00000">B A</font></td></tr>
<tr><th>13.</th><td>[4]101100..</td><td>(3) <font color="#c00000">1 0 1</font> </td><td>(4)<font color="#c00000">A B A</font></td><td>(2)<font color="#c00000">C A</font></td><td>(62)<font color="#c00000">A A B</font></td></tr>
<tr><th>14.</th><td>[4]011100..</td><td>(3) <font color="#c00000">0 1 1</font> </td><td>(4)<font color="#c00000">B A A</font></td><td>(3)<font color="#c00000">B A A</font></td><td>(67)<font color="#c00000">A C</font></td></tr>
<tr><th>15.</th><td>[4]111100..</td><td>(4) <font color="#c00000">1 1 1 1</font> </td><td>(4)<font color="#c00000">A A A A</font></td><td>(3)<font color="#c00000">C B A</font></td><td>(60)<font color="#c00000">A A A A A</font></td></tr>
<tr><th>16.</th><td>[5]000010..</td><td>(5) <font color="#c00000">0 0 0 0</font> </td><td>(4)<font color="#c00000">C C</font></td><td>(4)<font color="#c00000">A   A  A  A</font></td><td>(93)<font color="#c00000">C B</font></td></tr>
<tr><th>17.</th><td>[5]100010..</td><td>(5) <font color="#c00000">1 0 0 0</font> </td><td>(5)<font color="#c00000">A C B</font></td><td>(3)<font color="#c00000">B B B</font></td><td>(86)<font color="#c00000">A B A A A</font></td></tr>

</tbody></table>

 When the wrights are 1 2 2 you actually have the standard huffman
expansion of 
A = 1
B = 01
C = 00
for most of the 0's and 1's when not at end of string
however when EOS occurs there are many ways to make a bijection
choosing a diffrent method will change the ends and for the program here
it actually might be better off.  You can change bit_byts if a different transform
is to be used.

What the code does is it actually go through two bijective transforms.
The first changes the 1 0 string to an infinite finitely odd file.
then you use the arithmetic decompressor to get another infinite finitely
odd file and bijectively transform that to the symbol space.
Since at each stage your always trying to map things of different
length something has to give and it can occur twice.

Example level 3 strings fom the unique binary 1 1 1 to 0 1 1
go to level 3 and level 4  of the finitely odd file. 
the level 3 finitely odd map to levels 2 and 3 in w122 
and level 4 fintiely odd map to levels 3 and 4 in w122

The point is every sting of ones and zeros has a unique expansion
in A B C  where the weights except for the level shifts at the very
end of string match the way one wants for messages order.

W122 is the old classical huffman weighting
W111 is the classical 3 symbols of all equal weight.
if you have binary in 1 0 and wishs to change to a 3 symbol
code this is what you would use.

W 12 38 55  is just a random possible weighting one might come across.
 

Now for a practical example of where Reverse Arithmetic would be used
its a bit stream example for those who are interested in that sort of thing.
Suppose one is building a Mars Rover and that its trying to communicate
to earh with a long stream of data. Suppose it can only send 0's and 1's
suppose when your ready to seend the data its highly compressed and appears
to all statistical tests to be a random string of 0's and 1's  Suppose the cost
of sending a one is 1 unit and the cost of sending a 0 is 2 units. What is best
way to uncompress the stream using an arithemtic compressor like arb2x
to send the data for the least cost. I wrote the unarb3w for a 3 symbol case
this is the much easier 2 symbol case. But I think its an instructive example
one could easily mod arb2x to do the whole thing with arb3w as a guide.

The poor solution many noble people might first try is to weight the arithmetic
uncompressor for sending such that 1 uses 2/3 the space and 0 uses 1/3
the space.  Call this method one.  It the wrong way of doing it but lets look
at it.  
look at the transmitted 0 and 1
The length of a 0 in original input bits is ln(3)/ln(2) = 1.58496250072115618145373894394782
The length of a 1 in original input bits is ln(3/2)/ln(2) = 0.584962500721156181453738943947817
note since random one expects 1 to occur 2/3 of time in output bit stream
and 0  to ocurr 1/3 of the time so the actually this give in output bit stream
a length of output bits for every input bit to 1/0.91829583405448951478707227728
this means for every million bits in one expects to send 1088973.68681807866307862797911068
call this X characters out the cost for these characters is
1(2/3)( X) + 2(1/3)(X) is (4/3(X) = 1451964.91575743821743817063881333
to summare if cost of sending 1 is 1 and cost of send 0 is 2 if one use the
2: 1 split. and get 1/3 of time a zero and 2/3 of time a one.
For every 1,000,000 character in you send 1,088,974 character out
at a cost of 1,451,965

Know lets look at the opitmal serial solution. 
let p1 =  0.618033988749894848204586834365638 for a 1
and p2 = 0.381966011250105151795413165634362 for a 0
the length of 0 in original input bits is ln(1/p2)/ln2 = 1.38848382726123460347758053379719
the length of 1 in original input bits is ln(1/p1)ln(2) = 0.694241913630617301738790266900085
multiply by probability of occurance and get
length of output bits for every input bit = 1/0.959418728222744199142863005822959
this means for every million bit in one expects to send 1042297.76903816517762117429172565
now using probabilityes the cost to send is 1288350.89532754775244959416772444

in this case the optimal solution case 2 allows you to send the 1,000,000 bits
in 1,042,297 bits which is done with not only less chararters by several thousand
bits. But by a lower cost. of 1,288,351

In case your wondering if no reverse arithmetic compression done in one million bits you
would expect half zero and half one so the case cost would be 
1/2( 1 millon ) + 2(1/2)( 1 million)  1.5(1million) which is 1,500,000 

if no chanage the cost is
1,500,000.
if use the noble guess cost is
1,451,965
if you do it right the cost is
1,288,351

This is an example of reverse arithmetic.

This is also a real world example to I say this since
in Ham radio morse code is based on sending dots and dashes.
a dot is length X  of a burst of RF followed by slience of the same
length. A dash is a burst of RF 3 times the length of a dot and
the same amount of silence this means the dot is half the time
of a dash. If one sending a true stream of dots and dashes one
does not need the inter character gap.  That occurs when one
is sending individual characters.  looking at the number
ratio of the ones and zeros ( dots and dashes ) one could get
an idea how much thought was given to the design. If
there is roughly an equal number of dots and dashes then
no thought of saving transmitting power was used.  If the
ratio is two to one. Then what I call an average amount of
consideration was used. If the stream is such that it
closely matches the ratio of dots and dashes by the weights
done in a reverse arithmetic compression
then there is a high degress of  thought given to the trasmission
since if it came from battery system they are conserving power
this is something a spy might use from an intelligent nation.
I say this since its the right way to do it. I don't actually think
the US smart enough to look for such signals or use such signals.
We are not hungry enough to bother with it.
  Let me explain this thought a little farther. If your a spy
you want to limit the time of the transmission. If the device
sends dots and dashes in a burst with the timing above.
if one occurs roughly 0.618 of the time and the other
0.312 of the time then you have some one using state of
the art equipment. For this is the ratio to send the most
information in the shortest time when the dot dash
ratio is 2:1.











</pre></b></font>

 MORE LATER
if i get enough feed back

 

<center>
<a href="https://web.archive.org/web/20210805175333/http://bijective.dogma.net/index.htm">ENTER here for MY Home Page</a><br>
<!--
<H3>Please Turn off JavaScript Active-x or any advanced features before entering</H3> </CENTER>
-->



</center></body></html>
<!--
     FILE ARCHIVED ON 17:53:33 Aug 05, 2021 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 00:53:16 Nov 26, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.51
  exclusion.robots: 0.027
  exclusion.robots.policy: 0.017
  esindex: 0.01
  cdx.remote: 13.056
  LoadShardBlock: 209.712 (3)
  PetaboxLoader3.datanode: 92.252 (4)
  PetaboxLoader3.resolve: 86.533 (2)
  load_resource: 102.288
-->